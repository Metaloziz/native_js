
### Type Script

    ReturnType<Type> - Создает тип, состоящий из возвращаемого типа функции Type.
    Partial<Type> - делает все ключи НЕ обязательными
    Required<Type> - делает все ключи Обязательными
    Readonly<Type> - только на один уровень вложенности
    Record<Keys, Type> - cоздаёт тип объекта, ключами свойств которого являются Keys, а значениями свойств являются Type
    Pick<Type, Keys> - выбирает набор свойств Keys
    Omit<Type, Keys> - выбирает все свойства Type и затем удаляя Keys
    Exclude<UnionType, ExcludedMembers> - исключает повторения
    NonNullable<Type> - исключает null и undefined из Type.
    Parameters<Type> - создает тип кортежа из типов, используемых в параметрах типа функции Type.
    ...
    дальше утилиты для классов

    # Typescript является языком со статической типизацией. Тип не может быть изменен в ходе выполнения программы

    inteface и type взаимозаменяемые, только в interface нельзя создать тип из примитивов. typ A = '1' | '2'
    inteface не может описать тип кортежа | Tuple
    inteface  не может создать Union тип. т.е. type A, type B and type C = A | B
    НО inteface расширяется а type нет

    итого inteface можно использовать для объектов приходящих по API,
    а type в частных случаях: type Nullable<T> = T | null | undefined

    ## || vs &&

    0 || 2 - возвращает правду // 2
    0 && 2 - возвращает лож // 0

    ## автоматическая типизация
    let aaa = 'string'
    aaa = 10 // TS2322: Type 'number' is not assignable to type 'string'.



### ООП

    Два подхода написания кода - процедурный (основан на функциях и входных данных) VS ООП подход.
    ## ООП основан на инкапсуляции, наследовании и полиморфизме.
    # инкапсуляции - скрывает детали
    # наследовании - переиспользуем код
    # полиморфизме - с разными объектами работаем по одним методам
    Полиморфизм бывает параметрическим(истинным) и ad-hoc(мнимый).
    Мнимый - это когда два метода с одинаковым именем принимают два параметра и складывают их,
    только один принимает number а второй string. Или приведение типов.
    Истинный - с разными объектами (созданными от разных классов) работаем по одним методам

    #   агрегация  (лат. aggregatio «присоединение»)
        композиция (лат. compositio — составление, связывание, сложение, соединение)
    композиция - автомобиль состоит из элементов, которые ему необходимы (колёса, двигло) они же создаются внутри класса.
    Но туда же можно запихнуть и бегемота, т.е. бегемот на прямую не связан с авто,
    но в частном случае используется там. Т.е. Бегемот создан где-то снаружи и помещен в класс через конструктор.
    Итого композиция и агрегация это СПОСОБЫ взаимодействия между классами.

    # Абстрактные классы и интерфейсы
    # Имплемента́ция (с англ «implementation», реализация):

    # dependency injection  - надо повторить

    # singleton - из одного класса может быть создан только один экземпляр.
    Сколько бы раз мы не вызывали класс, он будет возвращать один и тот же объект.


    # Class
      private - методы доступны только внутри класса, значения для них нужно передавать в super,
      но они не доступны в наследнике и в экземпляре наследника.
      protected - свойства наследуются и доступны в наследниках, но не доступны в экземплярах.
      static - свойства которые инициализируются стразу в классе, т.е. им не нужно передавать знaчения через constructor.

      # имплементация возможна от интерфейса, в котором есть абстрактный метод


### SOLID

    Что такой хороший код ?
        1) Масштабируемый.
        2) Низкий порог входа.
        3) Простой уровень написания.

    S - Single-responsiblity Principle
        Для каждого класса должно быть определено единственное назначение.
        Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы
        в этот класс и подчинены только этой задаче.

        Одна сущность - одна задача.
        Декомпозиция - разбиваем большие задачи на мелкие.
        Разделение данных и методов.

    O - Open-closed Principle
        «программные сущности … должны быть открыты для расширения, но закрыты для модификации».

        Расширение не ломает старого функционала, оно даже не соприкасается.

    L - Liskov Substitution Principle
        «объекты в программе должны быть заменяемыми на экземпляры их подтипов без
        изменения правильности выполнения программы».
        т.е. расширенный класс можно подставить вместо бати.

    I - Interface Segregation Principle
        «много интерфейсов, специально предназначенных для клиентов, лучше,
        чем один интерфейс общего назначения».
        Или
        UlbiTV. Программные сущности не должны зависеть от методов которые они не используют.
        Или
        Нельзя заставлять клиента реализовывать интерфейс, которым он не пользуется.

        Пример: если в форме есть поля для ФИО и для паспортных данных, то нужно их разделить.
        Пример 2: если мы в функцию передаём объект с тремя ключами, но используем
        только два, то этот принцип нарушается.

        Если у нас еть общий тип, но его отдельные блоки используются в других
        местах программы, а ненужные мы игнорируем или делаем заглушки, то этот принцип нарушается.

        Плюс: код становиться менее связанным.

    D - Dependency Inversion Principle
        «Зависимость на Абстракциях. Нет зависимости на что-то конкретное».
        Или
        UlbiTV. Модули высокого уровня не должны зависеть от модулей низкого уровня,
        все они должны зависеть от абстракций, а абстракции не должны зависеть от деталей,
        только детали должны зависеть от абстракций.

        Пример: если в машине меняется деталь, то из-за неё мы не должны менять вид топлива
        и аккумулятор. Т.е. она должна работать как и старая, и требовать то же октановое число и вольтаж аккума.






















React-Redux все хуки
все хуки и API Redux
Патерны проектирования, основные
Контекст функции, aplly, binde,
FLUX
Алгоритмические задачи.

знаю теорию
SOLID
Vanila JS
прототип наследования
Методы жизненного цикла компонент
что происходит после ввода в строку поиска
ООП (Классы, как это реализованно, proto prototype)
REST
Приведение типов

только слышал
Клиент-серверная-архитектура
графQL
Sagi
