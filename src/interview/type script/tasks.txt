
### Type Script

    ReturnType<Type> - Создает тип, состоящий из возвращаемого типа функции Type.
    Partial<Type> - делает все ключи НЕ обязательными
    Required<Type> - делает все ключи Обязательными
    Readonly<Type> - только на один уровень вложенности
    Record<Keys, Type> - cоздаёт тип объекта, ключами свойств которого являются Keys, а значениями свойств являются Type
    Pick<Type, Keys> - выбирает набор свойств Keys
    Omit<Type, Keys> - выбирает все свойства Type и затем удаляя Keys
    Exclude<UnionType, ExcludedMembers> - исключает повторения
    NonNullable<Type> - исключает null и undefined из Type.
    Parameters<Type> - создает тип кортежа из типов, используемых в параметрах типа функции Type.
    ...
    дальше утилиты для классов

    # Typescript является языком со статической типизацией. Тип не может быть изменен в ходе выполнения программы

    inteface и type взаимозаменяемые, только в interface нельзя создать тип из примитивов. typ A = '1' | '2'
    inteface не может описать тип кортежа | Tuple
    inteface  не может создать Union тип. т.е. type A, type B and type C = A | B
    НО inteface расширяется а type нет

    итого inteface можно использовать для объектов приходящих по API,
    а type в частных случаях: type Nullable<T> = T | null | undefined

    ## || vs &&

    0 || 2 - возвращает правду // 2
    0 && 2 - возвращает лож // 0

    ## автоматическая типизация
    let aaa = 'string'
    aaa = 10 // TS2322: Type 'number' is not assignable to type 'string'.


### ООП

    Два подхода написания кода - процедурный (основан на функциях и входных данных) VS ООП подход.
    ## ООП основан на инкапсуляции, наследовании и полиморфизме.
    # инкапсуляции - скрывает детали
    # наследовании - переиспользуем код
    # полиморфизме - с разными объектами работаем по одним методам
    Полиморфизм бывает параметрическим(истинным) и ad-hoc(мнимый).
    Мнимый - это когда два метода с одинаковым именем принимают два параметра и складывают их,
    только один принимает number а второй string. Или приведение типов.
    Истинный - с разными объектами (созданными от разных классов) работаем по одним методам.
    Полиморфизм уменьшает связность системы.

    #   агрегация  (лат. aggregatio «присоединение»)
        композиция (лат. compositio — составление, связывание, сложение, соединение)
    композиция - автомобиль состоит из элементов, которые ему необходимы (колёса, двигло) они же создаются внутри класса.
    Но туда же можно запихнуть и бегемота, т.е. бегемот на прямую не связан с авто,
    но в частном случае используется там. Т.е. Бегемот создан где-то снаружи и помещен в класс через конструктор.
    Итого композиция и агрегация это СПОСОБЫ взаимодействия между классами.

    # Абстрактные классы и интерфейсы
    # Имплемента́ция (с англ «implementation», реализация):

    # dependency injection  - надо повторить

    # singleton - из одного класса может быть создан только один экземпляр.
    Сколько бы раз мы не вызывали класс, он будет возвращать один и тот же объект.

    # Итак, наше определение ООП это:
      Техника использующая динамический полиморфизм чтобы вызывать функции и
      не создающая зависимостей вызвающего от вызываемого на уровне исходного кода.

    # Class
      private - методы доступны только внутри класса, значения для них нужно передавать в super,
      но они не доступны в наследнике и в экземпляре наследника.
      protected - свойства наследуются и доступны в наследниках, но не доступны в экземплярах.
      static - свойства которые инициализируются стразу в классе, т.е. им не нужно передавать знaчения через constructor.

      # имплементация возможна от интерфейса, в котором есть абстрактный метод

      Сlass - нужны чтобы клепать однотипные объекты.

### proto prototype

    __proto__ - есть у всех объектов, почти всегда это объект.
    __proto__ разных по типу объектов являются разными независимыми объектами(Number / String).
    У одинаковых по типу объектов __proto__ всегда равны.
    Чтобы понимать, что за __proto__ нужно точно знать с помощью какой функции конструктора (класса)
    создан данный объект.

    Любой объект в JS создаётся с помощью функции конструктора. new Promise, {} // new Object, ...

    class в JS это надстройка над над функцией конструктором - function SupperClass(){}

    prototype - есть либо у Class или function

    Если мы пытаемся прочитать совйство объекта, либо вызвать метод, а данного ключа нету,
    то объект полезет искать его через ссылку __proto__ в prototype класса, с помощью
    которого он был создан.

    прототип наследования - done
    Контекст функции, aplly, binde - done

    let a = 10
    a.__proto__     // Number
    let b = "qwe"
    b.__proto__     //String
    let c = ()=>{}
    c.__proto__     //    ƒ () { [native code] }
    let d = true
    d.__proto__     //    Boolean
    function qwe (){}
    qwe.__proto__   //    ƒ () { [native code] }

    Ключи в объектах prototype не итерируемые, так как enumerable: false.


### SOLID


    Что такой хороший код ?
        1) Масштабируемый.
        2) Низкий порог входа.
        3) Простой уровень написания.

    S - Single-responsiblity Principle
        Для каждого класса должно быть определено единственное назначение.
        Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы
        в этот класс и подчинены только этой задаче.

        Одна сущность - одна задача.
        Декомпозиция - разбиваем большие задачи на мелкие.
        Разделение данных и методов.

    O - Open-closed Principle
        «программные сущности … должны быть открыты для расширения, но закрыты для
        модификации».

        Расширение не ломает старого функционала, оно даже не соприкасается.

    L - Liskov Substitution Principle
        «объекты в программе должны быть заменяемыми на экземпляры их подтипов без
        изменения правильности выполнения программы».
        т.е. расширенный класс можно подставить вместо бати.

    I - Interface Segregation Principle
        «много интерфейсов, специально предназначенных для клиентов, лучше,
        чем один интерфейс общего назначения».
        Или
        UlbiTV. Программные сущности не должны зависеть от методов которые они не
        используют.
        Или
        Нельзя заставлять клиента реализовывать интерфейс, которым он не пользуется.

        Пример: если в форме есть поля для ФИО и для паспортных данных, то нужно их
        разделить.
        Пример 2: если мы в функцию передаём объект с тремя ключами, но используем
        только два, то этот принцип нарушается.

        Если у нас еть общий тип, но его отдельные блоки используются в других
        местах программы, а ненужные мы игнорируем или делаем заглушки, то этот
        принцип нарушается.

        Плюс: код становиться менее связанным.

    D - Dependency Inversion Principle
        «Зависимость на Абстракциях. Нет зависимости на что-то конкретное».
        Или
        UlbiTV. Модули высокого уровня не должны зависеть от модулей низкого уровня,
        все они должны зависеть от абстракций, а абстракции не должны зависеть от
        деталей, только детали должны зависеть от абстракций.

        Пример: если в машине меняется деталь, то из-за неё мы не должны менять вид
        топлива и аккумулятор. Т.е. она должна работать как и старая, и требовать то
        же октановое число и вольтаж аккума.

### Патерны

    Паттерн проектирования — это часто встречающееся решение определённой проблемы
    при проектировании архитектуры программ.

    Порождающие паттерны беспокоятся о гибком создании объектов без внесения в
    программу лишних зависимостей.

    Структурные паттерны показывают различные способы построения связей между
    объектами.

    Поведенческие паттерны заботятся об эффективной коммуникации между объектами.


    # Структурные:

        Адаптер — позволяет объектам с несовместимыми интерфейсами работать вместе.

        Мост —  разделяет один или несколько классов на две отдельные иерархии —
        абстракцию и реализацию, позволяя изменять их независимо друг от друга.
        Например, вынести из автомобиля создание двигателя в отдельный класс

        Компоновщик —  позволяет сгруппировать множество объектов в древовидную
        структуру, а затем работать с ней так, как будто это единичный объект.

        Декоратор — позволяет динамически добавлять объектам новую функциональность,
        оборачивая их в полезные «обёртки».

        Фасад — предоставляет простой интерфейс к сложной системе классов,
        библиотеке или фреймворку.

        Легковес — позволяет вместить бóльшее количество объектов в отведённую
        оперативную память. Легковес экономит память, разделяя общее состояние
        объектов между собой, вместо хранения одинаковых данных в каждом объекте.

        Заместитель — позволяет подставлять вместо реальных объектов специальные
        объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту,
        позволяя сделать что-то до или после передачи вызова оригиналу.
        Заместитель «притворяется» базой данных, ускоряя работу за счёт ленивой
        инициализации и кеширования повторяющихся запросов.

    # Порождающие:

       Фабричный метод — определяет общий интерфейс для создания объектов в
        суперклассе, позволяя подклассам изменять тип создаваемых объектов.
        Подклассы могут изменять класс создаваемых объектов.

        Абстрактная фабрика — позволяет создавать семейства связанных объектов,
        не привязываясь к конкретным классам создаваемых объектов.

        Строитель — позволяет создавать сложные объекты пошагово. Строитель даёт
        возможность использовать один и тот же код строительства для получения
        разных представлений объектов. Класс.

        Прототип — это порождающий паттерн проектирования, который позволяет
        копировать объекты, не вдаваясь в подробности их реализации.
        У экземпляра класса вызвается метод clone который копирует этот объект.

        Одиночка — это порождающий паттерн проектирования, который гарантирует,
        что у класса есть только один экземпляр, и предоставляет к нему глобальную
        точку доступа.

    # Поведенческие:

        Итератор — это поведенческий паттерн проектирования, который даёт возможность
        последовательно обходить элементы составных объектов, не раскрывая их
        внутреннего представления. Идея паттерна Итератор состоит в том, чтобы
        вынести поведение обхода коллекции из самой коллекции в отдельный класс.

        Наблюдатель — это поведенческий паттерн проектирования, который создаёт
        механизм подписки, позволяющий одним объектам следить и реагировать на
        события, происходящие в других объектах. Формирует зависимость один ко
        многим.

        Цепочка обязанностей — позволяет передавать запросы последовательно по
        цепочке обработчиков. Каждый последующий обработчик решает, может ли он
        обработать запрос сам и стоит ли передавать запрос дальше по цепи. Нужно
        возвращать this из функции и будете цепочка.

        Команда — превращает запросы в объекты, позволяя передавать их как аргументы
        при вызове методов, ставить запросы в очередь, логировать их, а также
        поддерживать отмену операций. Пример: redux с типами экшенов.

        Посредник (медиатор) — это поведенческий паттерн проектирования, который
        позволяет уменьшить связанность множества классов между собой, благодаря
        перемещению этих связей в один класс-посредник. Пример: самолёты в воздухе
        общаются не на прямую, а через диспетчера.

        Состояние — позволяет объектам менять поведение в зависимости от своего
        состояния. Извне создаётся впечатление, что изменился класс объекта.
        Пример: переключение светофора.

        Стратегия — определяет семейство схожих алгоритмов и помещает каждый из них
        в собственный класс, после чего алгоритмы можно взаимозаменять прямо во
        время исполнения программы. Например: класс который из набора однотипных
        объектов получает коеретные данные (например средний возраст по странам).

        Шаблонный метод — определяет скелет алгоритма, перекладывая ответственность
        за некоторые его шаги на подклассы. Паттерн позволяет подклассам
        переопределять шаги алгоритма, не меняя его общей структуры.


### FLUX

    Ключевая концепция: Хранилище — единственная сущность в вашем приложении,
    которая знает как изменить данные. Это самая важная часть Flux. Событие,
    которые мы послали, не знает как добавить или удалить элемент. Суть
    однонаправленный поток данных.

    Построенный на однонаправленных потоках данных.

### Методы жизненного цикла компонент
    // https://habr.com/ru/post/358090/

    # монтирование

        constructor(props): конструктор, в котором происходит начальная
        инициализация компонента.

        getDerivedStateFromProps(props, state) - синхронизация.
        Основная ответственность этой новой функции — это убедиться, что состояние
        (state) и props синхронизированы, когда это необходимо

        render(): рендеринг компонента

        componentDidMount(): вызывается после рендеринга компонента. Вызывается
        после рендера дочерних элементов. Т.к. эта функция гарантирована будет
        вызвана лишь раз, то это превосходный кандидат для выполнения любых
        сайд-эффектов, как то AJAX запросы.

    # обновление

        getDerivedStateFromProps(props, state) - синхронизация.

        shouldComponentUpdate(). Выполняем сравнение старых свойств с
        новым перечнем свойств либо сравнивать состояния. При этом мы можем указать,
        надо ли отображать компонент заново, возвращая true либо false

        render(): рендеринг компонента

        componentDidUpdate(prevProps, prevState, prevContext). Эта функция будет
        вызываться после того как отработала функция render, в каждом цикле
        перерисовки. Это означает, что вы можете быть уверены, что компонент и все
        его дочерние компоненты уже перерисовали себя.

    # размонтирование

        componentWillUnmount(): вызывается перед удалением компонента из DOM

### Приведение типов
    // https://dorey.github.io/JavaScript-Equality-Table/
    // https://habr.com/ru/company/ruvds/blog/347866/

    Первая особенность работы с типами в JS, о которой нужно знать, заключается в
    том, что здесь есть только три вида преобразований:

    В строку (String)
    В логическое значение (Boolean)
    В число (Number)

    Например, alert автоматически преобразует любое значение к строке.

    Вторая особенность JS, которую нужно учитывать, заключается в том, логика
    преобразования для примитивных типов и для объектов работает по-разному, но и
    примитивы и объекты могут быть конвертированы в эти три типа. Начнём с
    примитивных типов данных.

    Number(null)                   // 0
    Number(undefined)              // NaN
    Number(true)                   // 1
    Number(false)                  // 0
    Number(" 12 ")                 // 12
    Number("-12.34")               // -12.34
    Number("\n")                   // 0
    Number(" 12s ")                // NaN
    Number(123)                    // 123

    Number(null)                   // 0
    null == 0                      // false    wtf ?

    Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два
    операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют
    «аргументами» вместо «операндов».

    Унарным называется оператор, который применяется к одному операнду. Например,
    оператор унарный минус "-" меняет знак числа на противоположный:
        let x = 1
        x = -x;
        alert( x ); // -1, применили унарный минус

    Бинарным называется оператор, который применяется к двум операндам. Тот же минус
    существует и в бинарной форме:
        let x = 1, y = 3;
        alert( y - x ); // 2, бинарный минус вычитает значения

    Формально, в последних примерах мы говорим о двух разных операторах,
    использующих один символ: оператор отрицания (унарный оператор, который
    обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно
    число из другого).

### Клиент-серверная-архитектура

    HTTP протокол - основа.

    плюсы:
    - все вычисления происходят на сервере.
    - все данные на сервере.
    - на сервере проще организовать контроль к данным.

    минус:
    - не работает сервер - не работает всё.

    Тонкий клиент: браузер, он просто посредник. Обработка и хранение данных
    происходит на сервере.

    Толстый клиент: любые онлайн игры, которое обрабатывает информацию локально, а на
    сервер отправляет только запросы на сохранение(изменение) даннных.

    Веб-сайт - информационный ресурс. Любой контент(текс, музыка, видео).
    Веб-приложения - позволяют потреблять и добавлять контент в приложение. YouTube ...
    Веб-сервис - это прикладной API. SOAP REST. Позволяет различнми веб-приложениям
    взаимодействаовать между собой. Например из инсты оправить сообщение в телеграмм.

        SOAP - стандартный протокол. Использует XML
        REST - более гибкий. Используем JSON.

    Transmission Control Protocol (TCP) - цельный
    UDP User Datagram Protocol - поток


### Что происходит после ввода в строку поиска
    https://habr.com/ru/company/htmlacademy/blog/254825/


### REST
    https://www.youtube.com/watch?v=WNy2x8ykWgA
    Повзволяет единообразно выполнять CRUD операции.

    API - интерфейст. Может быть у сайта, приложения или у куска кода. API класса
    это его методы.

    WebAPI - это часть браузера, которая за нас формирует запрос т.е. к запросу
    "фильмы" довешивает header, cooks, и прочее.

    REST - это соглашения по которым разрабатываеются WebAPI.
    Representational State Transfer — «передача репрезентативного состояния»
    или «передача „самоописываемого“ состояния»). Aрхитектурный стиль
    взаимодействия компонентов распределённого приложения в сети. Другими словами,
    REST — это набор правил того, как программисту организовать написание кода
    серверного приложения, чтобы все системы легко обменивались данными и приложение
    можно было масштабировать.

    Требования к рест:
        1. Модель клиент-сервер
        2. Отсутствие состояния
            в период между запросами клиента никакая информация о состоянии клиента
            на сервере не хранится
        3. Кэширование
        4. Единообразие интерфейса
        5. Слои. Отсылка к DNS.


### React-Redux

    # API

        Необходимо наше приложение обернутьв <Provider/>


    # Hooks

        useSelector()
        Возвращает данные из стейта. Запускает рендер при изменении своих данных.
        Использует строгую проверку.

        useDispatch()
        Этот хук возвращает ссылку на dispatch функцию из хранилища Redux.
        Вы можете использовать его для отправки действий по мере необходимости.
        Согласно документауции Dispatch неизменени, но useEffect и прочиие об этом не
        знают, поэтому проще добавить в зависимости.

        useStore()
        Этот хук возвращает ссылку на то же хранилище Redux, которое было передано
        <Provider> компоненту.

        useActions() - убрали

        connect() - это функция-оболочка, которая берет ваш компонент и возвращает
        компонент-оболочку с дополнительными реквизитами, которые он внедряет.

        batch() - собирает несеолько диспатчей и обновляет всё за один рендер.
        В 18й версии реакта это происходит автоматом.

    # Redux

        getState()
        dispatch(action)
        subscribe(listener) - срабатывает на некоторые изменения в стейте.
        replaceReducer(nextReducer)
        combineReducers(reducers)
        applyMiddleware(...middleware) - добавляет дополнительный функционал,
        чаще все это thunk - для асинхронных запросов.
        bindActionCreators(actionCreators, dispatch).
        compose(...functions) - соединяет несколько дополнений
        compose(applyMiddleware(thunk), DevTools.instrument()).

### Saga
    https://redux-saga.js.org/

    Основаны на генераторах. В стор необходимо добавлять прослойку "sagaMiddleware".

    Добавление слоя в стор:
        import { createStore, applyMiddleware } from 'redux'
        import createSagaMiddleware from 'redux-saga'

        import reducer from './reducers'
        import mySaga from './sagas'

        const sagaMiddleware = createSagaMiddleware() // create the saga middleware

        const store = createStore(
          reducer,
          applyMiddleware(sagaMiddleware)   // mount it on the Store
        )

        sagaMiddleware.run(mySaga)  // then run the saga

    Вместо диспатча в генераторах работает pull. Асинхронную функцию вызывает call.
    Есть функции watcher and worker - это таже санка. Только она запускается после
    того как задиспатчили опрелённый экшен, который зарегистрировать в watcher.

### GRAPHQL

    Это синтаксис, который описывает как запрашивать данные. И в основном
    используется клиентом для загрузки данныйх с сервера.

    Отличие от оыбчного запроса:
    У сервера есть один эндпоинт и даже если нам нужно только ID и NAME пользователя,
    сервер все равно вернёт нам всё. GRAPHQL сервер же может доставать только
    необходимые нам данные.

    # Основные понятия:
    SCHEMA - описание данных (условно типизация)
    QUERY - конкретные ключ которые нам необходимы.
    MUTATION - позволяет измененить данные, т.е. это аналог PUT, POST в HTTP.
    SUBSCRIPTION - клиент в режиме реального времени слушает изменения в БД.
    Основано на WebSocket

    GRAPHQL - необходимо реализовать в виде сервера на любой платформе.




Vanila JS
Алгоритмические задачи.

