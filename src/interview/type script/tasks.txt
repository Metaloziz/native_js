
### Type Script

    ReturnType<Type> - Создает тип, состоящий из возвращаемого типа функции Type.
    Partial<Type> - делает все ключи НЕ обязательными
    Required<Type> - делает все ключи Обязательными
    Readonly<Type> - только на один уровень вложенности
    Record<Keys, Type> - cоздаёт тип объекта, ключами свойств которого являются Keys, а значениями свойств являются Type
    Pick<Type, Keys> - выбирает набор свойств Keys
    Omit<Type, Keys> - выбирает все свойства Type и затем удаляя Keys
    Exclude<UnionType, ExcludedMembers> - исключает повторения
    NonNullable<Type> - исключает null и undefined из Type.
    Parameters<Type> - создает тип кортежа из типов, используемых в параметрах типа функции Type.
    ...
    дальше утилиты для классов

    # Typescript является языком со статической типизацией. Тип не может быть изменен в ходе выполнения программы

    inteface и type взаимозаменяемые, только в interface нельзя создать тип из примитивов. typ A = '1' | '2'
    inteface не может описать тип кортежа | Tuple
    inteface  не может создать Union тип. т.е. type A, type B and type C = A | B
    НО inteface расширяется а type нет

    итого inteface можно использовать для объектов приходящих по API,
    а type в частных случаях: type Nullable<T> = T | null | undefined

    ## || vs &&

    0 || 2 - возвращает правду // 2
    0 && 2 - возвращает лож // 0

    ## автоматическая типизация
    let aaa = 'string'
    aaa = 10 // TS2322: Type 'number' is not assignable to type 'string'.



### SOLID

### ООП
    Два подхода написания кода - процедурный (основан на функциях и входных данных) VS ООП подход.
    ## ООП основан на инкапсуляции, наследовании и полиморфизме.
    # инкапсуляции - скрывает детали
    # наследовании - переиспользуем код
    # полиморфизме - с разными объектами работаем по одним методам
    Полиморфизм бывает параметрическим(истинным) и ad-hoc(мнимый).
    Мнимый - это когда два метода с одинаковым именем принимают два параметра и складывают их,
    только один принимает number а второй string. Или приведение типов.
    Истинный - с разными объектами (созданными от разных классов) работаем по одним методам

    #   агрегация  (лат. aggregatio «присоединение»)
        композиция (лат. compositio — составление, связывание, сложение, соединение)
    композиция - автомобиль состоит из элементов, которые ему необходимы (колёса, двигло) они же создаются внутри класса.
    Но туда же можно запихнуть и бегемота, т.е. бегемот на прямую не связан с авто,
    но в частном случае используется там. Т.е. Бегемот создан где-то снаружи и помещен в класс через конструктор.
    Итого композиция и агрегация это СПОСОБЫ взаимодействия между классами.

    # Абстрактные классы и интерфейсы
    # Имплемента́ция (с англ «implementation», реализация):

    # dependency injection  - надо повторить

    # singleton - из одного класса может быть создан только один экземпляр.
    Сколько бы раз мы не вызывали класс, он будет возвращать один и тот же объект.


    # Class
      private - методы доступны только внутри класса, значения для них нужно передавать в super, но они не доступны в наследнике и в экземпляре наследника.
      protected - свойства наследуются и доступны в наследниках, но не доступны в экземплярах.
      static - свойства которые инициализируются стразу в классе, т.е. им не нужно передавать знaчения через constructor.






















React-Redux все хуки
все хуки и API Redux
Патерны проектирования, основные
Контекст функции, aplly, binde,
FLUX
Алгоритмические задачи.

знаю теорию
SOLID
Vanila JS
прототип наследования
Методы жизненного цикла компонент
что происходит после ввода в строку поиска
ООП (Классы, как это реализованно, proto prototype)
REST
Приведение типов

только слышал
Клиент-серверная-архитектура
графQL
Sagi
